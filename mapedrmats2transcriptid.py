# -*- coding: utf-8 -*-
"""mapedrMATS2transcriptID.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xHamM7tSO4u1ffboXZiFOihANI4vUAv6

**Bibliotecas**:
1. *gffutils*:

  1.1. manipulação de arquvos GFF e GTF

  1.2. Cria um banco de dados do GTF(função create_db)

  1.3. Condulta regiões por coordenadas (função db.region) e filtra por feature

2. *pandas*:

  2.1. Manipulação de tabelas e dados

  2.2. lê e itera cada linha dos arquivos de splicing do rMATS (função pd.read_csv)

  2.3. Cria a tabela final de resultados (função pd.DataFrame)

3. *argparse*

  3.1. criação de argumentos de linha de comando
"""

#!pip install gffutils
#!python3 drive/MyDrive/Colab\ Notebooks/mapedrMATS2transcriptID.ipynb --gtf Cryptococcus_neoformans_var_grubii_h99_gca_000149245.CNA3.55.gtf --rmats A3SS.MATS.JCEC.txt --tipo_evento A3SS --out teste.tab

#!/usr/bin/env python3
import gffutils as gu #manipulação de arquivos gff e gtf e criação de banco de dados
import pandas as pd #para criação do resultado final
import argparse #para criação de argumentos

##################################
# Argumentos de entrada de dados #
##################################
parser = argparse.ArgumentParser(description="Mapear eventos do rMATS com os transcript_id dos arquivos GTF")
parser.add_argument("--gtf", required=True, help="Entre com o arquivo GTF utilizado no mapeamento")
parser.add_argument("--rmats", required=True, help="Arquivo de saída do rMATS (.MATS.JC.txt, JCEC.txt). Informe um por vez")
parser.add_argument("--tipo_evento", required=True, help="Tipo de evento: SE, RI, A3SS, A5SS ou MXE. Informe conforme o arquivo do rMATS fornecido")
parser.add_argument("--out", required=True, help="Arquivo de saída com mapeamento")
args = parser.parse_args()

####################################################
# Criando o banco de dados a partir do arquivo GTF #
####################################################

print("Criando o banco de dados a partir do arquivo GTF...")
db = gu.create_db(
    args.gtf,
    dbfn="gtf.db", #Caminho para o banco de dados que será criado
    force=True, #para sobrescrever db existentes
    keep_order=True,
    merge_strategy="merge", #merge para que os transcripts_id fiquem na mesma linha
    sort_attribute_values=True, #Todos os recursos retornados do banco de dados terão seu atributo valores classificados
    disable_infer_genes=True, #Retirar essa função caso o arquivo GTF não tenha as features
    disable_infer_transcripts=True #Retirar essa função caso o arquivo GTF não tenha as features
)

#########################
# Lendo o arquivo rMATS #
#########################

print(f"Lendo o arquivo rMATS: {args.rmats}")
rmats = pd.read_csv(args.rmats, sep="\t")

################################################################################
# Criação de uma função para pegar as coordenadas de cada evento: SE, RI, A3SS,#
# A5SS e MXE                                                                   #
################################################################################

def coords (line, type):
  if type == "SE":
    return (line['chr'], line['exonStart_0base']+1, line['exonEnd'], line['strand'])
  elif type == "RI":
    return (line['chr'], line['riExonStart_0base']+1, line['riExonEnd'], line['strand'])
  elif type == "MXE":
    return (line['chr'], line['1stExonStart_0base']+1, line['1stExonEnd'], line['strand'])
  elif type == "A3SS":
    return (line['chr'], line['longExonStart_0base']+1, line['longExonEnd'], line['strand'])
  elif type == "A5SS":
    return (line['chr'], line['longExonStart_0base']+1, line['longExonEnd'], line['strand'])
  else:
    raise ValueError("Por favor informe um evento válido: SE, RI, A3SS, A5SS e MXE")

################################################################################
# Mapeando os os genes vs. transcript_id                                       #                                                       #
################################################################################

print("Mapeando os os genes vs. transcript_id.")

results = []

for _, line in rmats.iterrows():
    chrom, start, end, strand = coords(line, args.tipo_evento)

    # Padronizar nome do cromossomo
    if chrom.startswith("chr"):
        chrom = chrom[3:]
    
    evento_id = line.get('ID', line.iloc[0])    

     #verifica overlap entre os transcritos
    for feat in db.region(region=(chrom, start-5, end+5), strand=strand,
                          featuretype='exon'):
        tid = feat.attributes.get('transcript_id', ['NA'])[0]
        gid = feat.attributes.get('gene_id', ['NA'])[0]
        results.append({
            "Evento": line['ID'],
            "Gene_ID": gid,
            "Transcript_ID": tid,
            "Chr": chrom,
            "Start": start,
            "End": end,
            "Strand": strand
        })

######################
# Saída do resultado #                                                       #
######################

out_df = pd.DataFrame(results).drop_duplicates()
out_df.to_csv(args.out, sep="\t", index=False)
print(f"Mapeamento salvo em: {args.out}")
